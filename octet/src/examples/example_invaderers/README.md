####Delainey Ackerman
####Intro to Game Programming
####Assignment 1: Basic 2D game mod from example_invaders
####November 2016

#####[Link for demo video] (https://youtu.be/ejbD38uXy2k)

######Game Description:
Fight your way through multiple levels, defending your territory from the copycat Link Invaders.  
Take cover behind walls, but look out! They don't last forever. 

######Major Additions:
* Define Player and Enemy Playing Spaces
  * I used a fifth, invisible border sprite as a divider between player and invader game areas. The invaders can move in roughly the upper two thirds of the game window. Once the lowermost invader reaches the dividing border, all invaders begin to move back upscreen. After the top most invader reaches the top border all invaders will switch to once again move downscreen towards the player.
  * This is implemented similarly to the invader velocity determining if the invaders are moving left to right (positive) direction across the screen, or right to left (negative) direction. In *simulate()* I perform a check after moving the invaders to see if any invader sprite collided with the top or dividing border in addition to the exisisting check to determine if the invaders hit a left or right border and need to change direction. 
  ``` cpp
  float invader_direction;
  ...
  // Middle Divider and Top
  sprite &borderTop = sprites[first_border_sprite + (invader_direction < 0 ? 4 : 1)];
  if (invaders_collide(borderTop)) {
    invader_direction = -invader_direction;
    move_invaders(invader_velocity, invader_direction); 
  }
  ``` 
  
*  Add Wall Sprites That Take Multiple Damage Hits Before Destruction
  * I added an different group of sprites, called walls, to the enumerator in *invaderers_app*. These walls  
  are a type of sprite that can take 3 hits of damage, visually deteriorating after each hit, before being  
  destroyed. Beyond setting up textures, collision detection, and initializing the wall sprites, the main  
  implementation required for the wall functionality was adapting the *Sprite* class to keep track of  
  the number of lives remaining and swap out the appropriate textures after each damage hit.
  * Wall with 3 damage hits left 
  * ![wall3](../../../assets/invaderers/wall3.gif)
  * Wall with 2 damage hits left
  * ![wall2](../../../assets/invaderers/wall2.gif)
  * Wall with 1 damage hit left
  * ![wall1](../../../assets/invaderers/wall1.gif)
  * I implemented a second constructor to the *Sprite* class to allow sprites to have multiple lives. The original constructor was changed to default the number of lives to 1. With this implimentation any sprite could be initialized with multiple lives (or damage hit points) which would be useful in extending this code to include boss level enemies or additional strong and weak cover sprites. I added simple getter and setter functions so that life counter is a private member variable and the upkeep of each sprite's lives is not directly changed by any outside class. I also switched the player (or ship) sprite over to use this second constructor to eleminate the use of one of the sundry game counters initialized in *app_init()* to track the number of player lives left used to determine the overal game state.  
  ``` cpp
  // Second constructor used for player, walls, and other sprites with multiple lives
  void init(int _texture, float x, float y, float w, float h, int life) {
    modelToWorld.loadIdentity();
    modelToWorld.translate(x, y, 0);
    halfWidth = w * 0.5f;
    halfHeight = h * 0.5f;
    texture = _texture;
    enabled = true;
    lives = life;
  }
  ```
  * In order to change the texture after each time the wall is hit I added one more function to the  
  *Sprite* class.
  ``` cpp
  // update sprite texture with new image
    void change_texture(GLuint _texture) {
      texture = _texture;
    }
  ```
  * This way when a collision with a projectile and a wall sprite is triggered and the wall is not  
  completely destroyed, the game within the *invader_app* class can build a file path string to the
  wall texture with one fewer lives remaining and pass that texture in to the wall sprite to update
  the graphic.
  ``` cpp
  // Damage wall
  if (currLives > 1) {
    wall.life_lost();
    std::string wallTextureFile = "assets/invaderers/wall" +  std::to_string(--currLives) + ".gif";
    // example std::string from StackOverflow goo.gl/6ntDg2
    newTexture = resource_dict::get_texture_handle(GL_RGBA, wallTextureFile.c_str());
    wall.change_texture(newTexture);
  }
  ``` 
  
* Multiple Levels Generated by Reading CSV File
  * Adapted from Andy Thomason's [read a CSV example] (https://github.com/andy-thomason/read_a_csv_file/blob/master/main.cpp) I wrote a simple function to open a CSV file, step  
  through each line storing information for the initial positions of each invader, wall, and the player in  
  the current level. Additional game levels are easily set up in a spreadsheet using 'I' to place an invader, 'W' to place a wall, and 'P' to position the player's starting position. Because of the natural grid structure of a spreadsheet this method of level creation makes a great visual representation of how each level will be set up and balanced. 
  * I use three vectors storing integer pairs of x, y coordinates for each invader, wall, and player position found in the csv file. My function to *read_csv()* is called from the *app_init()* function so that the beginning of each game and game level can read in a unique csv. The function is passed in the addresses of each of the three vectors so that after reading the csv, *app_init()* has access to all the coordinate pairs. One by one I dump each line of the csv file into a character array. I use 100 as the max length of my array because I know that the length of each line is limited by the number of columns in the game space multiplied by two to account for both the possible character indicating a sprite placement and the comma separating each grid space. Once the character array stores the line information, I step through each character in the line checking for 'I', 'W', and 'P' characters. If a comma character is found I increment the current X grid position and if an end of line character '0' is found then I increment the Y grid position and load the next line into the character array. 
  
* Game States: Restart, Pause, and Next Level
  * The first game state functionality I added was to restart the game after winning or losing. I added a game restart sprite that appeared on screen whenever the game was over indicating that the game could be restarted by pressing 'R'. Then in *simulate()* if the game is over and the 'R' key is pressed, *app_init()* is called to reload the game.
  ```cpp
  if (game_over) {
    if (is_key_down(key_R)) {
      app_init();
    }
    ...
    return;
  }
  ```
  * Next I added the ability to pause and unpause the game. This also occurs in *simulate()* as the game needs to listen every frame to see if the 'P' key was pressed. In this case I used the *is_key_going_down()* function to check for key presses so that action of pausing or unpausing only occurs once per key press even if the key is pressed down for multiple frames. 
  ```cpp
  // Pause and unpause game using 'P'
  if (!game_paused) {
    if (is_key_going_down(key_P)) {
      game_paused = true;
      sprites[game_pause_sprite].translate(-20, 0);
      return;
    }
  }
  else {
    if (is_key_going_down(key_P)) {
      game_paused = false;
      sprites[game_pause_sprite].translate(20, 0);
      goto move_ship;
    }
    return;
  }
  ```
  * Finally, if the game level was won, indicated by all invader sprites being disabled, then an option to advance to the next level becomes available. In this case, pressing 'N' will increment the current level as long as the player has not reached the final level. The game will then call *app_init()* to reload the game, using the new current level to load the next csv file. 
  ```cpp
  if (game_won) {
    if (is_key_down(key_N)) {
      if (currLevel < MAXLEVEL) {
        currLevel++;
      }
      app_init();
    }
  }
  ```
* Uniform Shader: tint color of player texture based on number of lives left
  * I modified the [texture_shader.h] (https://github.com/dack91/octet/blob/master/octet/src/shaders/texture_shader.h) file to be able to tint the color of any texture based on a parameter containing an array of floats representing the R,G,B and Alpha values by which to change the normal applied texture. I did this so that the appearance of the player character can visually change colors after each life lost without loading in a different texture to the player sprite. I added the float array parameter to the *render()* function in *texture_shader.h* from which the values of that array are used to set up a *uniform vec4*. The *vec4* can then be used to tint the applied texture by multiplying it by the normal 2D texture created for the *gl_FragColor* used to color the sprite. 
  ```cpp
  void render(const mat4t &modelToProjection, int sampler, float color[]) {
    ...
    // customize the program with uniforms
    ...
    glUniform4fv(colorIndex, 1, color); // set up uniform for tinting individual sprite colors
  }
  ...
  // extract the indices of the uniforms to use later
  colorIndex = glGetUniformLocation(program(), "tintSpriteColor");
  ...
  uniform vec4 tintSpriteColor;
  void main() {
    // multiply shader by vec4 to tint color of rendered sprite based on game state
    gl_FragColor = texture2D(sampler, uv_) * tintSpriteColor; 
  }
  ```
  * Then back in *invaderers_app.h* I can pass in a default color tint to use for all sprites that I don't want to modify the applied texture. 
  ```cpp
  float defaultColor[4] = {1.0f, 1.0f, 1.0f, 1.0f};
  ```
  * And for the player sprite I can change the player tint each time a life is lost, making the sprite progressively more red before the game is over and the sprite is entirely red. The fourth element of the array is not changed as the alpha value remains fully opaque throughout the game. 
  ```cpp
  float livesLeftColor[4];
  ...
  // change player sprite color when life lost
    void on_life_lost() {
        livesLeftColor[0] = 1.0f;
        livesLeftColor[1] = livesLeftColor[1] - 0.33f;
        livesLeftColor[2] = 0.0f;
    }
  ```

######Minor Modifications:
* Add Additional Key Press Functionality
  * I modified [app_common.h] (https://github.com/dack91/octet/blob/master/octet/src/platform/app_common.h) by adding more ascii keys to the key enumerator used to navigate game states like Pause, Restart, and Next Level.
  ```cpp
  enum key {
    ...
    // additional keys with ascii codes
    key_R = 82,
    key_P = 80,
    key_N = 78,
    key_enter = 13,
    ...
   }
   ```
  
* Vertical Player Movement
  * I added up and down movement to the *move_ship()* class by checking for up and down key presses and ensuring that the player remains within the game play area by checking for collisions with the bottom and divider border sprites. If the player moves to collide with one of those boundaries, apply an equal and oppisite movement so that the sprite stays in one place inside of the allowed area.
  ```cpp
  // up arrow
  else if (is_key_down(key_up)) {
    sprites[ship_sprite].translate(0, +ship_speed);
    if (sprites[ship_sprite].collides_with(sprites[first_border_sprite+4])) {
      sprites[ship_sprite].translate(0, -ship_speed);
    }
  }
  ```  
* Self Defense: Destroy bombs with missiles
  * I modified *move_missiles()* to iterate through bomb sprites and check for colisions in addition to the  
  existing checks if the missile collided with any active invader sprites or any of the damagable walls  
  implemented and described earlier. This modification finilizes the three methods the player can use to  
  avoid being hit by invader bombs: take cover behind temporary walls, dodge the attack with four directional  
  movement, and shoot a missile at the bomb to destroy both projectiles.
  * I also initiated bombs closer to the player in order to fix bug which allowed a player to hide underneath    
  a wall and shoot through it without damaging the wall because the missile was initiated too far in front  
  of the player on the other side of the wall. 
  ``` cpp
  // Initialize missile closer to ship so it can't shoot through walls
  sprites[first_missile_sprite+i].set_relative(sprites[ship_sprite], 0, 0.15f);
  ```

* Changed Sprite Source Images and Game Colors 
  * I changed the look of the game to match the concept of being earth bound game where two teams defend their separate play regions and attack by launching projectiles into the opposition's play area, much like a dodgeball match. I changed the color of the background and border sprites to feel more ground and border wall like, and then in Photoshop I modified stock images of Zelda's Link to give each team, player and invaders, a separate jersey color. 
  * Player
  * ![player](../../../assets/invaderers/player.gif)
  * Invader
  * ![invader](../../../assets/invaderers/enemy.gif)


